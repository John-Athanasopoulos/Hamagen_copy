//Random Waypoint Model
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <ctime>

using namespace std;

template<class T>
class ChainNode;
template<class T>
class Chain{
public:
    Chain() {first = nullptr;} //creates chain
    ~Chain(){ //destroys chain
        ChainNode<T> *next;

        while (first) { //deletes node and then proceeds to delete the next one etc.
            next = first->link;
            delete first;
            first = next;
        }
    }

    bool IsEmpty() const { //checks if chain is empty (true if it is, false if it has at least one node)
        return first == 0;
    }

    int Length() const{ //returns the length of the chain
        ChainNode<T> *currentNode = first;
        int chainLength = 0;
        while (currentNode){ //for every transition to the next node, the chainLength is augmented by 1
            chainLength++;
            currentNode = currentNode->link;
        }
        return chainLength;
    }

    bool Details(int f, T& x, T& y, T& h) const{ //Finds a specific node (the one with index=f)
        if (f < 1) return false; //There can't be a chain with nodes<=0
        ChainNode<T> *currentNode = first;
        int counter = 1;
        while (counter < f && currentNode) { //We iterate through the list until we find the node with index=f
            currentNode = currentNode->link;
            counter++;
        }
        if (currentNode) { //if the node is found, it is currently held by currentNode and we get its data
            x = currentNode->data[0];
            y = currentNode->data[1];
            h = currentNode->data[2];
            cout << "X-axis: " << x << "||" << "Y-axis: " << y << "||" << "Health: " << h << endl;

            return true;
        }
        return false; //the node with index=f was not found
    }

    int Search(const T& x) const{ //search for a node (x)
        ChainNode<T> *currentNode = first;
        int counter = 1;
        while (currentNode && currentNode->data != x) { //runs when currentNode is not x
            currentNode = currentNode->link;
            counter++;
        }
        if (currentNode){ //if it is found, return its index
            return counter;
        }
        return 0;
    }

    Chain<T>& Delete(int k, T& x){
        if (k < 1 || !first){ //if the node index (k) is incorrect (k<=0) or the first pointer is null
            cout << "ERROR: Out of Bounds Exception.."; //The exception could not be thrown
        }
        ChainNode<T> *p = first;
        if (k == 1){ //if we want to delete the first node, we make the second node the Head node
            first = first->link;
        }
        else { //We make all the adjustments (linking the correct nodes) and then delete the node we want
            ChainNode<T> *q = first;
            for (int i = 1; i < k - 1 && q; i++)
                q = q->link;
            p = q->link;
            q->link = p->link;
        }
        x = p->data;
        delete p;
        return *this;
    }

    Chain<T>& FirstNodeCreation(int currX, int currY, int healthy){ //Creation of the First Node of the Chain
        auto *y = new ChainNode<T>(currX,currY,healthy); //creation of Node Pointer
        y->data[0] = currX;
        y->data[1] = currY;
        y->data[2] = healthy;
        return *this;
    }

    Chain<T>& Insert(int k){ //Insert Node
        ChainNode<T> *p = first;
        for (int i = 1; i < k && p; i++){
            p = p->link;
        }
        int currX = p->destinationX;
        int currY = p->destinationY;
        int healthy = p->healthy;
        auto *d = new ChainNode<T>(currX,currY,healthy); //creation of Node Pointer
        d->data[0]=currX;
        d->data[1]=currY;//Assign data to the new Node (data = x)
        d->data[2]=healthy;
        if (k) { //in this case p's link is assigned to d's link and then p gets linked with d
            d->link = p->link;
            p->link = d;
        }
        else { //in this case d's link gets the value of the first node's position (so that d is linked to the first node) and then d becomes the first node
            d->link = first;
            first = d;
        }
        return *this;
    }

    void Output(){ //Outputs the whole chain in the following format: node1-node2-etc
        ChainNode<T> *tmp;
        tmp=first;
        while(tmp){ //when it reaches the end, tmp becomes null. Else, if the chain is empty, it doesn't print anything
            cout << tmp->data[0]<<", "<<tmp->data[1]<<", "<< tmp->data[2] << "-";
            tmp = tmp->link;
        }
        cout<<endl;
    }
private:
    ChainNode<T> *first;
};

template<class T>
class ChainNode {
public:
    friend Chain<T>;

    int healthy; // 1 f healthy, 0 if ill
    int destinationX; // destination on the X axis
    int destinationY; // destination on the Y axis
    int currentX; // the current value on the X axis
    int currentY; // the current value on the Y axis
    float speed; // The speed the human will go to the destination

    ChainNode(int x, int y, int health){
        currentX = x;
        currentY = y;
        healthy = health;
    }

    int findDestinationX(){
        int destinationX = rand()%60;
        return destinationX;
    }

    int findDestinationY(){
        int destinationY = rand()%60;
        return destinationY;
    }

    float humanSpeed(){
        float speed = (static_cast <float> (rand()) / (static_cast <float> (RAND_MAX / 3))) + 3;
        return speed;
    }

    T setNode(){
        int currX = this->currentX;
        int currY = this->currentY;
        int healthy = this->healthy;
        this->data = {currX, currY, healthy};
        return data;
    }

    T data[3];

private:
    ChainNode<T> *link;
};




int main(){
    srand ( time(nullptr) );
    int startingX = rand()%61;
    int startingY = rand()%61;
    Chain<int> h1;
    h1.FirstNodeCreation(startingX, startingY,1);
    h1.Insert(1);
    int n=0;
    int displayX;
    int displayY;
    int displayHealth;
    h1.Details(1,displayX,displayY,displayHealth);
    return 0;
}
