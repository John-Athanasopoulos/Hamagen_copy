//Random Waypoint Model
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <ctime>

using namespace std;

template<class T>
class ChainNode;
template<class T>
class Chain {
public:
    Chain() { first = 0; } //creates chain
    ~Chain() { //destroys chain
        ChainNode<T>* next;

        while (first) { //deletes node and then proceeds to delete the next one etc.
            next = first->link;
            delete first;
            first = next;
        }
    }

    bool IsEmpty() const //checks if chain is empty (true if it is, false if it has at least one node)
    {
        return first == 0;
    }

    int Length() const { //returns the length of the chain
        ChainNode<T>* currentNode = first;
        int chainLength = 0;
        while (currentNode) { //for every transition to the next node, the chainLength is augmented by 1
            chainLength++;
            currentNode = currentNode->link;
        }
        return chainLength;
    }

    bool Details(int f, T& x, T& y, T& h) const //Finds a specific node (the one with index=f)
    {
        if (f < 1) return false; //There can't be a chain with nodes<=0
        ChainNode<T>* currentNode = first;
        int counter = 1;
        while (counter < f && currentNode) { //We iterate through the list until we find the node with index=f
            currentNode = currentNode->link;
            counter++;
        }
        if (currentNode) { //if the node is found, it is currently held by currentNode and we get its data
            x = currentNode->data[0];
            y = currentNode->data[1];
            h = currentNode->data[2];
            cout << "X-axis: " << x << "||" << "Y-axis: " << y << "||" << "Health: " << h << endl;

            return true;
        }
        return false; //the node with index=f was not found
    }

    int Search(const T& x) const //search for a node (x)
    {
        ChainNode<T>* currentNode = first;
        int counter = 1;
        while (currentNode && currentNode->data != x) { //runs when currentNode is not x
            currentNode = currentNode->link;
            counter++;
        }
        if (currentNode) { //if it is found, return its index
            return counter;
        }
        return 0;
    }

    Chain<T>& Delete(int k)
    {
        if (k < 1 || !first) { //if the node index (k) is incorrect (k<=0) or the first pointer is null
            cout << "ERROR: Out of Bounds Exception.."; //The exception could not be thrown
        }
        ChainNode<T>* p = first;
        if (k == 1) { //if we want to delete the first node, we make the second node the Head node
            first = first->link;
        }
        else { //We make all the adjustments (linking the correct nodes) and then delete the node we want
            ChainNode<T>* q = first;
            for (int i = 1; i < k - 1 && q; i++)
                q = q->link;
            p = q->link;
            q->link = p->link;
        }
        delete p;
        return *this;
    }

    Chain<T>& FirstNodeCreation(int currX, int currY, int healthy) //Creation of the First Node of the Chain
    {
        ChainNode<T>* y = new ChainNode<T>(currX, currY, healthy); //creation of Node Pointer
        y->ChainNode<T>::setNode();
        y->data[0] = currX;
        y->data[1] = currY;
        y->data[2] = healthy;
        first = y;
        return *this;
    }

    Chain<T>& Insert(int k) //Insert Node
    {
        ChainNode<T>* p = first;
        if (p->link)
            for (int i = 1; i < k && p; i++) {
                p = p->link;
            }
        while (k-- > 0) {
            int currX = rand() % 61;
            int currY = rand() % 61;
            int healthy = rand() % 2;
            ChainNode<T>* y = new ChainNode<T>(currX, currY, healthy); //creation of Node Pointer
            y->ChainNode<T>::setNode();
            y->data[0] = currX;
            y->data[1] = currY;
            y->data[2] = healthy;
            p->link = y;
            p = p->link;
        }

        return *this;
    }

    Chain<T>& InsertBetween(int k, int x, int y, int h)
    {
        ChainNode<T>* u = first;
        if (u->link && u) {
            for (int index = 1; index < k-1; index++) {
                u = u->link;
            }
        }
        /*int currX = rand() % 61;
        int currY = rand() % 61;
        int healthy = rand() % 2;*/
        bool l = true;
        while (l) {
            int currX = x;
            int currY = y;
            int healthy = h;
            ChainNode<T>* t = new ChainNode<T>(currX, currY, healthy);
            t->ChainNode<T>::setNode();
            t->data[0] = currX;
            t->data[1] = currY;
            t->data[2] = healthy;
            u->link = t;
            t->link = u->link;
            l = false;
        }
        
        return *this;
    }


    void Output()  //Outputs the whole chain in the following format: node1-node2-etc
    {
        ChainNode<T>* tmp;
        tmp = first;
        while (tmp) { //when it reaches the end, tmp becomes null. Else, if the chain is empty, it doesn't print anything
            cout << " -> " << "{" << tmp->data[0] << ", " << tmp->data[1] << ", " << tmp->data[2] << "}";
            tmp = tmp->link;
        }
        cout << endl;
    }
private:
    ChainNode<T>* first;
};

template<class T>
class ChainNode {
public:
    friend Chain<T>;

    int healthy; // 1 if healthy, 0 if ill
    int destinationX; // destination on the X axis
    int destinationY; // destination on the Y axis
    int currentX; // the current value on the X axis
    int currentY; // the current value on the Y axis
    float speed; // The speed the human will go to the destination

    ChainNode(int x, int y, int health)
    {
        currentX = x;
        currentY = y;
        healthy = health;
    }

    int findDestinationX()
    {
        int destinationX = rand() % 61;
        return destinationX;
    }

    int findDestinationY()
    {
        int destinationY = rand() % 61;
        return destinationY;
    }

    float humanSpeed()
    {
        float speed = (static_cast <float> (rand()) / (static_cast <float> (RAND_MAX / 3))) + 3;
        return speed;
    }

    void setNode()
    {
        int currX = this->currentX;
        int currY = this->currentY;
        int healthy = this->healthy;
        this->data[0] = currX;
        this->data[1] = currY;
        this->data[2] = healthy;
    }

    int data[3];

private:
    ChainNode<T>* link;
};

int main()
{
    srand(time(0));
    int displayX;
    int displayY;
    int displayHealth;
    int startingX = rand() % 61;
    int startingY = rand() % 61;
    Chain<int> h1;
    h1.FirstNodeCreation(startingX, startingY, 1);
    h1.Output();
    h1.Insert(100);
    h1.Output();
    cout << endl;
    h1.InsertBetween(5, 0, 0, 0);
    //h1.Delete(1); Deletes first node
    h1.Output();
    cout << endl;
    //h1.Details(3, displayX, displayY, displayHealth);

    //h1.Details(1, displayX, displayY, displayHealth);
    return 0;
}
