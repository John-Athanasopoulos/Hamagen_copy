//Random Waypoint Model
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <ctime>

#define R 10

using namespace std;

template<class T>
class ChainNode;
template<class T>
class Chain {
public:
    Chain() { first = 0; } //creates chain
    ~Chain() { //destroys chain
        ChainNode<T>* next;

        while (first) { //deletes node and then proceeds to delete the next one etc.
            next = first->link;
            delete first;
            first = next;
        }
    }

    bool IsEmpty() const //checks if chain is empty (true if it is, false if it has at least one node)
    {
        return first == 0;
    }

    int Length() const { //returns the length of the chain
        ChainNode<T>* currentNode = first;
        int chainLength = 0;
        while (currentNode) { //for every transition to the next node, the chainLength is augmented by 1
            chainLength++;
            currentNode = currentNode->link;
        }
        return chainLength;
    }

    bool Details(int f) const //Finds a specific node (the one with index=f)
    {
        if (f < 1) return false; //There can't be a chain with nodes<=0
        ChainNode<T>* currentNode = first;
        int counter = 1;
        while (counter < f && currentNode) { //We iterate through the list until we find the node with index=f
            currentNode = currentNode->link;
            counter++;
        }
        if (currentNode) { //if the node is found, it is currently held by currentNode and we get its data
            int x = currentNode->data[0];
            int y = currentNode->data[1];
            int h = currentNode->data[2];
            int d = currentNode->data[3];
            int s = currentNode->data[4];
            cout << "Day: " << d << "||" << "X-axis: " << x << "||" << "Y-axis: " << y << "||" << "Health: " << h << "||" << "Seconds: " << s << endl;

            return true;
        }
        return false; //the node with index=f was not found
    }

    int Search(const T& x) const //search for a node (x)
    {
        ChainNode<T>* currentNode = first;
        int counter = 1;
        while (currentNode && currentNode->data != x) { //runs when currentNode is not x
            currentNode = currentNode->link;
            counter++;
        }
        if (currentNode) { //if it is found, return its index
            return counter;
        }
        return 0;
    }

    Chain<T>& Delete(int k)
    {
        if (k < 1 || !first) { //if the node index (k) is incorrect (k<=0) or the first pointer is null
            cout << "ERROR: Out of Bounds Exception.."; //The exception could not be thrown
        }
        ChainNode<T>* p = first;
        if (k == 1) { //if we want to delete the first node, we make the second node the Head node
            first = first->link;
        }
        else { //We make all the adjustments (linking the correct nodes) and then delete the node we want
            ChainNode<T>* q = first;
            for (int i = 1; i < k - 1 && q; i++)
                q = q->link;
            p = q->link;
            q->link = p->link;
        }
        delete p;
        return *this;
    }

    Chain<T>& FirstNodeCreation(int currX, int currY, int healthy) //Creation of the First Node of the Chain
    {
        ChainNode<T>* y = new ChainNode<T>(currX, currY, healthy, 1); //creation of Node Pointer
        y->ChainNode<T>::setNode();
        y->data[0] = currX;
        y->data[1] = currY;
        y->data[2] = healthy;
        y->data[3] = 1; //first Node of every chain is created on the first day of the simulation
        y->data[4] = 30;
        first = y;
        return *this;
    }

    Chain<T>& Insert(int k, int day) //Insert Node
    {
        ChainNode<T>* p = first;
        while (p->link)
            p = p->link;

        while (k-- > 0) {
            int currX = rand() % 20;
            int currY = rand() % 20;
            int healthy = rand() % 2;
            ChainNode<T>* y = new ChainNode<T>(currX, currY, healthy, day); //creation of Node Pointer
            y->ChainNode<T>::setNode();
            y->data[0] = currX;
            y->data[1] = currY;
            y->data[2] = p->data[2]; // We continue with the same health
            y->data[3] = day;
            if (p->data[4] != 86400){
                y->data[4] = p->data[4] + 30; //This node's seconds are equal to the former one's + 30
            }
            else {
                y->data[4] = 30;
            }
            p->link = y;
            p = p->link;
        }

        return *this;
    }

    Chain<T>& InsertBetween(int k, int x, int y, int h, int daySim)
    {
        ChainNode<T>* p = first;

        if (p->link && p)
            for (int index = 1; index < k - 1; index++)
                p = p->link;

        ChainNode<T>* nextLink = p->link;

        ChainNode<T>* z = new ChainNode<T>(x, y, h, daySim); //creation of Node Pointer
        z->ChainNode<T>::setNode();
        z->data[0] = x;
        z->data[1] = y;
        z->data[2] = h;
        z->data[3] = daySim;
        z->data[4] = p->data[4] + 30;
        p->link = z;
        z->link = nextLink;

        return *this;
    }

    Chain<T>& REPAIR(int day)
    {
        ChainNode<T>* p = first;
        int counter = 1;

        while (p->data[3] < day) {
            p = p->link;
            counter++;
        }

        while (p->link && p->data[3] == day) {
            if (p->link->data[4] - p->data[4] > 30 && p->data[3] == p->link->data[3]) {
                int x = rand() % 61;
                int y = rand() % 61;
                int h = rand() % 2;
                InsertBetween(counter + 1, x, y, h, day);
            }
            else {
                p = p->link;
                counter++;
            }
        }

        return *this;
    }

    Chain<T>& SUMMARIZE_TRAJECTORY(int day, int daysBefore) {
        ChainNode<T>* p = first;

        while (p->link && !(p->data[3] >= day - daysBefore)) {
            p = p->link;
        }

        while (p->link) {
            if (p->data[3] >= day - daysBefore) {
                if (abs(p->data[0] - p->link->data[0]) < R && abs(p->data[1] - p->link->data[1]) < R) {
                    p->link = p->link->link;
                }
                else {
                    p = p->link;
                }
            }
            else {
                p = p->link;
            }
        }

        return *this;
    }

    void Output()  //Outputs the whole chain in the following format: node1-node2-etc
    {
        ChainNode<T>* tmp = first;
        while (tmp) { //when it reaches the end, tmp becomes null. Else, if the chain is empty, it doesn't print anything
            cout << " -> " << "{" << tmp->data[3] << ", " << tmp->data[0] << ", " << tmp->data[1] << ", " << tmp->data[2] << ", " << tmp->data[4] << "}";
            // -> { day, x, y, health, seconds }
            tmp = tmp->link;
        }
        cout << endl;
    }

    int FIND_CROWDED_PLACES(int day, int starting_sec, int ending_sec, SquareRegion a, int minStay) { //
        ChainNode<T>&* p = first;
        int user_count = 0; //how many users standed in this square area during the given time interval for at least the minStay time specified
        while (p->data[3] != day && p) {
            p = p->link; //link till the first node of the chosen day, or until we reach the end of the chain meaning the day was incorrect
        }
        if (p && 30 <= starting_sec && 86370 <= starting_sec && 30 <= ending_sec && 86400 <= ending_sec && starting_sec < ending_sec) { //all the prerequisites
            while (p->data[4] != starting_sec && p) {
                p = p->link; //link until we find the node with data[4] = starting_sec
            }
            int difference_sec = ending_sec - starting_sec; //The difference in seconds
            int numberNeeded = difference_sec % 30; //The nodes we need to check
            int counter = 0; // counts how many consecutive nodes are in the square (counter <= numberNeeded)
            int stayMinNodes = minStay % 30; //The minimum number of nodes needed for the method to return a value
            while (p && numberNeeded > 0) {
                if (p->data[0] >= a.minX && p->data[0] <= a.maxX && p->data[1] >= a.minY && p->data[1] <= a.maxY) {
                    counter++;
                }
                else {
                    counter = 0;
                }
                p = p->link;
                numberNeeded--;
            }
            if (counter >= stayMinNodes) {
                user_count = 1;
            }
        }
        else {
            cout << "The day, the starting second, the ending second or a combination of them is incorrect." << endl;
        }
        return user_count;
    }

private:
    ChainNode<T>* first;
};

template<class T>
class ChainNode {
public:
    friend Chain<T>;

    int healthy; // 1 if healthy, 0 if ill
    int destinationX; // destination on the X axis
    int destinationY; // destination on the Y axis
    int currentX; // the current value on the X axis
    int currentY; // the current value on the Y axis
    float speed; // The speed the human will go to the destination
    int currentDay; //The number of the current day
    int seconds; //The number of seconds since the beginning of the day

    ChainNode(int x, int y, int health, int day)
    {
        currentX = x;
        currentY = y;
        healthy = health;
        currentDay = day;
    }

    int findDestinationX()
    {
        int destinationX = rand() % 61;
        return destinationX;
    }

    int findDestinationY()
    {
        int destinationY = rand() % 61;
        return destinationY;
    }

    float humanSpeed()
    {
        float speed = (static_cast <float> (rand()) / (static_cast <float> (RAND_MAX / 3))) + 3;
        return speed;
    }

    void setNode()
    {
        int currX = this->currentX;
        int currY = this->currentY;
        int healthy = this->healthy;
        int day = this->currentDay;
        this->data[0] = currX;
        this->data[1] = currY;
        this->data[2] = healthy;
        this->data[3] = day;
    }

    int data[5];

private:
    ChainNode<T>* link;
};

class SquareRegion {
    public:
        int minX;
        int minY;
        int maxX;
        int maxY;

        SquareRegion(int miX, int miY, int maX, int maY) {
            minX = miX;
            minY = miY;
            maxX = maX;
            maxY = maY;
        }
};



void MakeSimulationChain(int stX, int stY, int stH, int simulationDays) {
    Chain<int>h1;
    h1.FirstNodeCreation(stX, stY, 1);
    h1.Insert(2879, 1);
    h1.Insert(2880, 8);
    int currDay = 2;
    while (currDay <= simulationDays) {
        h1.Insert(2880, currDay);
        currDay++;
    }
    h1.Output();
}

int main() {
    //Grid* grid = new Grid();
    SquareRegion SR1(0, 0, 20, 20);
    cout << SR1.maxX;
    SquareRegion SR2(21, 0, 40, 20);
    SquareRegion SR3(41, 0, 60, 20);
    SquareRegion SR4(0, 21, 20, 40);
    SquareRegion SR5(21, 21, 40, 40);
    SquareRegion SR6(41, 21, 60, 40);
    SquareRegion SR7(0, 41, 20, 60);
    SquareRegion SR8(21, 41, 40, 60);
    SquareRegion SR9(41, 41, 60, 60);
    srand(time(0));
    int displayX;
    int displayY;
    int displayHealth;
    int startingX = rand() % 61;
    int startingY = rand() % 61;
    Chain<int> h1;
    h1.FirstNodeCreation(startingX, startingY, 1);
    h1.Insert(2879, 1);
    h1.Insert(2880, 2);
    h1.Insert(2880, 3);
    h1.Delete(44);
    h1.Delete(82);
    h1.Delete(12);
    h1.Delete(96);
    h1.Delete(15);
    h1.Output();
    h1.REPAIR(1);
    h1.REPAIR(2);
    h1.REPAIR(3);
    cout << "\n\n\n" << endl;
    h1.Output();
    return 0;
}
