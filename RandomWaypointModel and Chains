//Random Waypoint Model
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <ctime>

#define R 10

using namespace std;

template<class T>
class ChainNode;
template<class T>
class Chain {
public:
    Chain() { first = 0; } //creates chain
    ~Chain() { //destroys chain
        ChainNode<T>* next;

        while (first) { //deletes node and then proceeds to delete the next one etc.
            next = first->link;
            delete first;
            first = next;
        }
    }

    bool IsEmpty() const //checks if chain is empty (true if it is, false if it has at least one node)
    {
        return first == 0;
    }

    int Length() const { //returns the length of the chain
        ChainNode<T>* currentNode = first;
        int chainLength = 0;
        while (currentNode) { //for every transition to the next node, the chainLength is augmented by 1
            chainLength++;
            currentNode = currentNode->link;
        }
        return chainLength;
    }

    bool Details(int f) const //Finds a specific node (the one with index=f)
    {
        if (f < 1) return false; //There can't be a chain with nodes<=0
        ChainNode<T>* currentNode = first;
        int counter = 1;
        while (counter < f && currentNode) { //We iterate through the list until we find the node with index=f
            currentNode = currentNode->link;
            counter++;
        }
        if (currentNode) { //if the node is found, it is currently held by currentNode and we get its data
            int x = currentNode->data[0];
            int y = currentNode->data[1];
            int h = currentNode->data[2];
            int d = currentNode->data[3];
            int s = currentNode->data[4];
            cout << "Day: " << d << "||" << "X-axis: " << x << "||" << "Y-axis: " << y << "||" << "Health: " << h << "||" << "Seconds: " << s << endl;

            return true;
        }
        return false; //the node with index=f was not found
    }

    int Search(const T& x) const //search for a node (x)
    {
        ChainNode<T>* currentNode = first;
        int counter = 1;
        while (currentNode && currentNode->data != x) { //runs when currentNode is not x
            currentNode = currentNode->link;
            counter++;
        }
        if (currentNode) { //if it is found, return its index
            return counter;
        }
        return 0;
    }

    Chain<T>& Delete(int k)
    {
        if (k < 1 || !first) { //if the node index (k) is incorrect (k<=0) or the first pointer is null
            cout << "ERROR: Out of Bounds Exception.."; //The exception could not be thrown
        }
        ChainNode<T>* p = first;
        if (k == 1) { //if we want to delete the first node, we make the second node the Head node
            first = first->link;
        }
        else { //We make all the adjustments (linking the correct nodes) and then delete the node we want
            ChainNode<T>* q = first;
            for (int i = 1; i < k - 1 && q; i++)
                q = q->link;
            p = q->link;
            q->link = p->link;
        }
        delete p;
        return *this;
    }

    Chain<T>& FirstNodeCreation(int currX, int currY, int healthy) //Creation of the First Node of the Chain
    {
        ChainNode<T>* y = new ChainNode<T>(currX, currY, healthy, 1); //creation of Node Pointer
        y->ChainNode<T>::setNode();
        y->data[0] = currX;
        y->data[1] = currY;
        y->data[2] = healthy;
        y->data[3] = 1; //first Node of every chain is created on the first day of the simulation
        y->data[4] = 30;
        first = y;
        return *this;
    }

    Chain<T>& Insert(int k, int day) //Insert Node
    {
        ChainNode<T>* p = first;
        while (p->link)
            p = p->link;

        while (k-- > 0) {
            int currX = rand() % 20;
            int currY = rand() % 20;
            int healthy = rand() % 2;
            ChainNode<T>* y = new ChainNode<T>(currX, currY, healthy, day); //creation of Node Pointer
            y->ChainNode<T>::setNode();
            y->data[0] = currX;
            y->data[1] = currY;
            y->data[2] = p->data[2]; // We continue with the same health
            y->data[3] = day;
            y->data[4] = p->data[4] + 30; //This node's seconds are equal to the former one's + 30
            p->link = y;
            p = p->link;
        }

        return *this;
    }

    Chain<T>& InsertBetween(int k, int x, int y, int h, int daySim)
    {
        ChainNode<T>* p = first;

        if (p->link && p)
            for (int index = 1; index < k - 1; index++)
                p = p->link;

        ChainNode<T>* nextLink = p->link;

        ChainNode<T>* z = new ChainNode<T>(x, y, h, daySim); //creation of Node Pointer
        z->ChainNode<T>::setNode();
        z->data[0] = x;
        z->data[1] = y;
        z->data[2] = h;
        z->data[3] = daySim;
        z->data[4] = p->data[4] + 30;
        p->link = z;
        z->link = nextLink;

        return *this;
    }

    Chain<T>& REPAIR(int day)
    {
        ChainNode<T>* p = first;
        int counter = 1;

        while (p->data[3] < day) {
            p = p->link;
            counter++;
        }

        while (p->link && p->data[3] == day) {
            if (p->link->data[4] - p->data[4] > 30 && p->data[3] == p->link->data[3]) {
                int x = rand() % 61;
                int y = rand() % 61;
                int h = rand() % 2;
                InsertBetween(counter + 1, x, y, h, day);
            } else {
                p = p->link;
                counter++;
            }
        }

        return *this;
    }

    Chain<T>& SUMMARIZE_TRAJECTORY(int day, int daysBefore) {
        ChainNode<T>* p = first;

        while (p->link && !(p->data[3] >= day - daysBefore)) {
            p = p->link;
        }

        while (p->link) {
            if (p->data[3] >= day - daysBefore) {
                if (abs(p->data[0] - p->link->data[0]) < R && abs(p->data[1] - p->link->data[1]) < R) {
                    p->link = p->link->link;
                } else {
                    p = p->link;
                }
            } else {
                p = p->link;
            }
        }

        return *this;
    }

    void Output()  //Outputs the whole chain in the following format: node1-node2-etc
    {
        ChainNode<T>* tmp = first;
        while (tmp) { //when it reaches the end, tmp becomes null. Else, if the chain is empty, it doesn't print anything
            cout << " -> " << "{" << tmp->data[3] << ", " << tmp->data[0] << ", " << tmp->data[1] << ", " << tmp->data[2] << ", " << tmp->data[4] << "}";
            // -> { day, x, y, health, seconds }
            tmp = tmp->link;
        }
        cout << endl;
    }

private:
    ChainNode<T>* first;
};

template<class T>
class ChainNode {
public:
    friend Chain<T>;

    int healthy; // 1 if healthy, 0 if ill
    int destinationX; // destination on the X axis
    int destinationY; // destination on the Y axis
    int currentX; // the current value on the X axis
    int currentY; // the current value on the Y axis
    float speed; // The speed the human will go to the destination
    int currentDay; //The number of the current day
    int seconds; //The number of seconds since the beginning of the day

    ChainNode(int x, int y, int health, int day)
    {
        currentX = x;
        currentY = y;
        healthy = health;
        currentDay = day;
    }

    int findDestinationX()
    {
        int destinationX = rand() % 61;
        return destinationX;
    }

    int findDestinationY()
    {
        int destinationY = rand() % 61;
        return destinationY;
    }

    float humanSpeed()
    {
        float speed = (static_cast <float> (rand()) / (static_cast <float> (RAND_MAX / 3))) + 3;
        return speed;
    }

    void setNode()
    {
        int currX = this->currentX;
        int currY = this->currentY;
        int healthy = this->healthy;
        int day = this->currentDay;
        this->data[0] = currX;
        this->data[1] = currY;
        this->data[2] = healthy;
        this->data[3] = day;
    }

    int data[5];

private:
    ChainNode<T>* link;
};

template<class T>
class ChainNode {
public:
    friend Chain<T>;

    int healthy; // 1 if healthy, 0 if ill
    int destinationX; // destination on the X axis
    int destinationY; // destination on the Y axis
    int currentX; // the current value on the X axis
    int currentY; // the current value on the Y axis
    float speed; // The speed the human will go to the destination
    int currentDay; //The number of the current day
    int seconds; //The number of seconds since the beginning of the day

    ChainNode(int x, int y, int health, int day)
    {
        currentX = x;
        currentY = y;
        healthy = health;
        currentDay = day;
    }

    int findDestinationX()
    {
        int destinationX = rand() % 61;
        return destinationX;
    }

    int findDestinationY()
    {
        int destinationY = rand() % 61;
        return destinationY;
    }

    float humanSpeed()
    {
        float speed = (static_cast <float> (rand()) / (static_cast <float> (RAND_MAX / 3))) + 3;
        return speed;
    }

    void setNode()
    {
        int currX = this->currentX;
        int currY = this->currentY;
        int healthy = this->healthy;
        int day = this->currentDay;
        this->data[0] = currX;
        this->data[1] = currY;
        this->data[2] = healthy;
        this->data[3] = day;
    }

    int data[5];

private:
    ChainNode<T>* link;
};

void MakeSimulationChain(int stX, int stY, int stH, int simulationDays) {
    Chain<int>h1;
    h1.FirstNodeCreation(stX, stY, 1);
    h1.Insert(2879,1);
    h1.Insert(2880, 8);
    int currDay = 2;
    while(currDay <= simulationDays) {
        h1.Insert(2880, currDay);
        currDay++;
    }
    h1.Output();
}

int main()
{
    srand(time(0));
    int startingX = 0; // rand() % 61;
    int startingY = 0; // rand() % 61;
    int simulationDays;
    //cout << "Number of simulation days: ";
    //cin >> simulationDays;
    //MakeSimulationChain(startingX,startingY,1,simulationDays);
    //cout << endl;
    Chain<int> h1;
    Chain<int> h2;
    h1.FirstNodeCreation(startingX, startingY, 1);
    h1.InsertBetween(2, 0, 0, 1);
    h1.InsertBetween(2, 0, 0, 1);
    h1.InsertBetween(2, 0, 0, 1);
    h1.Insert(96, 1);
    h1.Insert(100, 2);
    h1.SUMMARIZE_TRAJECTORY(3, 1, h1);
    /*startingX = rand() % 61;
    startingY = rand() % 61;
    h2.FirstNodeCreation(startingX, startingY, 0);
    h1.Insert(99, 1);
    h1.Delete(6);
    h1.Delete(15);
    h1.Delete(82);
    h1.Delete(45);
    h1.REPAIR(1, h1);*/
    //h1.InsertBetween(5, 0, 0, 0);
    //h1.Delete(1);// Deletes first node
    h1.Output();
    cout << endl;
    return 0;
}
